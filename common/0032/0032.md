# 解题思路：
## 动态规划解法一（内存超限）
将输入字符串全部遍历一次，并通过动态规划保存中间结果值，提高遍历效率。

以`dp[i][j]`表示输入字符串i下标至j下标是否有效。

动态规划递推公式如下：

-  如果`s[i] == ')' || s[j] == '('`或者i至j中间的字符个数是奇数，`dp[i][j] = false`
- 否则
1. 如果i、j相连，`dp[i][j] = 2`
2. 检查i、j中间是否有已经满足条件的字符串，如果有满足条件的字符串，可能出现以下两种情况，大括号内的字符表示已经确认为满足条件的字符串：

    - {ixxxxxx}yyyyj时，判断`dp[frist_y][j]`是否是有效字符串即可。由于需要通过最后个`last_x`的位置来确认`y`的位置，因此需要单独保存以`i`开头的最长的有效字符串截止位置，减少后续遍历次数。
    - i{xxxxx}j时，判断`s[i]`与`s[j]`是否配对即可

### 小结
由于需要二维数组保存所有子字符串的有效状态，以及单独的保存`last_x`的数组，使用过多内存，导致最终提交时内存超限。

## 动态规划解法二
在解法一的基础上，不再保存子字符串的有效状态，而是将原始字符串分割为数个独立、有效的子字符串。并通过`dp[i]`表示从下标`dp[i]`至`i`为有效字符串。结果计算时，取`MAX(i - dp[i])`即可。

动态规划递推公式如下，可能出现以下几种情况：

*大括号内表示当前遍历到的字符*
- `s[i-1]=='(' && s[i] == ')'`时，`dp[i] = i - 1`
- `s[i-1]==') && s[i] == ')'`时，需要判断`s[dp[i-1]-1]`是否是`'('`，也就是 `((()){)}`，多个括号包含的情况
-  **以上两种情况计算结果之后，都需要再额外判断在当前独立子字符串内是否还有相连的有效字符，比如说`xxxxxxx({)}`，在判断`()`连续之后，还需要再判断()之前的`xxxxx`是否为有效字符串，如果有效则需要在计算`dp[i]`时追溯到`first_x`的下标**

### 小结
由于本解法只需要遍历一次输入字符串，并且使用一维数组保存`dp[i]`至`i`有效字符串的下标，因此时间复杂度和空间复杂度都远小于解法一。
